<h1>组件</h1>
<p>什么是 Textbus 的组件？</p>
<p><strong style="color:rgb(58, 170, 250)">Textbus 组件是一个无关视图的数据模型</strong>。我们应当都使用过现代前端框架，如 React、Vue、Angular 等，组件带给我们良好的封装、丰富的功能、易于维护和扩展的开发体验。使用 Textbus 开发富文本组件，也可以像前端框架一样，只需要掌握少量的 API 以及生命周期等，即可开发出令人惊叹的富文本组件。当然，Textbus 的组件也有自己的特有的功能，如自动记录操作历史，支持插槽编辑等，不过，你基本无需关心这些，因为 Textbus 的内核已经帮你做好了。</p>
<p>一个最简单的 Textbus 组件结构如下：</p><pre lang="TypeScript" theme="starry" line-number class="tb-pre"><div class="tb-pre-content"><div style="width:2.5em" class="tb-code-line-number-bg"></div><div class="tb-code-content"><div class="tb-code-line"><span class="tb-hl-keyword">import</span>&nbsp;{ defineComponent, ContentType }&nbsp;<span class="tb-hl-keyword">from</span>&nbsp;<span class="tb-hl-string">'@textbus/core'</span></div><div class="tb-code-line"><br></div><div class="tb-code-line"><span class="tb-hl-keyword">const</span>&nbsp;rootComponent =&nbsp;<span class="tb-hl-function">defineComponent</span>({</div><div class="tb-code-line">&nbsp;&nbsp;name:&nbsp;<span class="tb-hl-string">'RootComponent'</span>,</div><div class="tb-code-line">&nbsp;&nbsp;type: ContentType.BlockComponent</div><div class="tb-code-line">})</div></div><span class="tb-pre-lang">TypeScript</span></div></pre>
<p>定义一个 Textbus 组件只需要调用&nbsp;<code>defineComponent</code>&nbsp;函数，并传入一个包含组件名和组件类型的配置对象即可。Textbus 不关心你将如何渲染这个组件，也就是说，你可以用任意的方式和 DOM 结构渲染 Textbus 的组件。</p>
<h2>如何渲染组件</h2>
<p>Textbus 官方提供了&nbsp;<a target="_blank" href="https://viewfly.org">Viewfly</a>、Vue 和 React 的渲染接入方式。你也可以使用其它方式渲染，只需要开发对应的视图适配器即可。</p>
<p>我们以 Viewfly 为例，当我们定义好 Textbus 的组件后，还需要定义一个与之对应的视图组件，并在适配器中关联它们。</p><pre lang="Tsx" theme="starry" line-number class="tb-pre"><div class="tb-pre-content"><div style="width:2.5em" class="tb-code-line-number-bg"></div><div class="tb-code-content"><div class="tb-code-line"><span class="tb-hl-keyword">import</span>&nbsp;{ Adapter }&nbsp;<span class="tb-hl-keyword">from</span>&nbsp;<span class="tb-hl-string">'@textbus/adapter-viewfly'</span></div><div class="tb-code-line"><br></div><div class="tb-code-line"><span class="tb-hl-keyword">function</span>&nbsp;<span class="tb-hl-function">RootComponentView</span>(props: ViewComponentProps&lt;<span class="tb-hl-keyword">typeof</span>&nbsp;yourComponent&gt;) {</div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-keyword">return</span>&nbsp;() =&gt; (&lt;<span class="tb-hl-tag">div&nbsp;</span><span class="tb-hl-attr-name">ref</span>={props.rootRef}&gt;....&lt;/<span class="tb-hl-tag">div</span>&gt;)</div><div class="tb-code-line">}</div><div class="tb-code-line"><br></div><div class="tb-code-line"><span class="tb-hl-keyword">const</span>&nbsp;adapter =&nbsp;<span class="tb-hl-keyword">new</span>&nbsp;<span class="tb-hl-class-name">Adapter</span>({</div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-comment">// 视图组件必须使用和 Textbus 组件相同的名字</span></div><div class="tb-code-line">&nbsp;&nbsp;[rootComponent.name]: RootComponentView</div><div class="tb-code-line">})</div></div><span class="tb-pre-lang">Tsx</span></div></pre>
<h3>视图组件 Props</h3>
<p>每一个视图组件都会接收到一个由 Textbus 传入的 Props。Props 结构如下：</p><pre lang="TypeScript" theme="starry" line-number class="tb-pre"><div class="tb-pre-content"><div style="width:2.5em" class="tb-code-line-number-bg"></div><div class="tb-code-content"><div class="tb-code-line"><span class="tb-hl-keyword">export</span>&nbsp;<span class="tb-hl-keyword">interface</span>&nbsp;<span class="tb-hl-class-name">ViewComponentProps</span>&lt;T<span class="tb-hl-class-name">&nbsp;</span><span class="tb-hl-keyword">extends</span><span class="tb-hl-class-name">&nbsp;Component&nbsp;</span>=<span class="tb-hl-class-name">&nbsp;Component</span>&gt; {</div><div class="tb-code-line">&nbsp;&nbsp;component: ExtractComponentInstanceType&lt;T&gt;</div><div class="tb-code-line">&nbsp;&nbsp;rootRef: Ref&lt;HTMLElement&gt;</div><div class="tb-code-line">}</div></div><span class="tb-pre-lang">TypeScript</span></div></pre>
<p>其中，component 为当前视图组件要渲染的 Textbus 组件实例（与适配器的的配置一一对应），rootRef 为组件根节点的 ref，<strong style="color:rgb(246, 48, 48)">你必须要把此 ref 实例添加到根节点的属性中</strong>，否则 Textbus 将无法区分原生 DOM 节点和组件的映射关系，导致不可预期的问题。</p>
<h2>动态组件</h2>
<p>如前面示例，我们创建的组件只有一个名字和类型，这种组件我们可以把它叫做静态组件，静态组件适用于一些数据不会产生变化的场景，如一张图片，一个视频等。而大多数情况，我们更需要一个动态组件。</p>
<p>动态组件可以帮助我们实现数据的更改和变化，在 Textbus 的动态组件中，我们不仅可以改变组件的状态，还可以使用插槽让组件内的一部分内容变成可编辑内容。</p>
<h3>创建动态组件</h3>
<p>要创建动态组件，我们只需要在组件初始化时，传入我们想要的数据，并在渲染时，根据传入的数据渲染即可。我们还是以前面的组件为例：</p><pre lang="Tsx" theme="starry" line-number class="tb-pre"><div class="tb-pre-content"><div style="width:2.5em" class="tb-code-line-number-bg"></div><div class="tb-code-content tb-color-content-highlight"><div class="tb-code-line"><span class="tb-hl-comment">// # doc.component.tsx</span></div><div class="tb-code-line"><span class="tb-hl-keyword">import</span>&nbsp;{ defineComponent }&nbsp;<span class="tb-hl-keyword">from</span>&nbsp;<span class="tb-hl-string">'@textbus/core'</span></div><div class="tb-code-line"><span class="tb-hl-keyword">import</span>&nbsp;{ ViewComponentProps }&nbsp;<span class="tb-hl-keyword">from</span>&nbsp;<span class="tb-hl-string">'@textbus/adapter-viewfly'</span></div><div class="tb-code-line"><br></div><div class="tb-code-line"><span class="tb-hl-comment">// 定义 Textbus 根组件数据模型</span></div><div class="tb-code-line"><span class="tb-hl-keyword">export</span>&nbsp;<span class="tb-hl-keyword">const</span>&nbsp;rootComponent =&nbsp;<span class="tb-hl-function">defineComponent</span>({</div><div class="tb-code-line">&nbsp;&nbsp;name:&nbsp;<span class="tb-hl-string">'RootComponent'</span>,</div><div class="tb-code-line">&nbsp;&nbsp;type: ContentType.BlockComponent</div><div class="tb-code-line">})</div><div class="tb-code-line"><br></div><div class="tb-code-line"><span class="tb-hl-comment">// 创建 RootComponentView 组件用于渲染 Textbus 根组件</span></div><div class="tb-code-line"><span class="tb-hl-keyword">export</span>&nbsp;<span class="tb-hl-keyword">const</span>&nbsp;RootComponentView = (props: ViewComponentProps&lt;<span class="tb-hl-keyword">typeof</span>&nbsp;rootComponent&gt;) =&gt; {</div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-keyword">return</span>&nbsp;() =&gt; {</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-keyword">return</span>&nbsp;(</div><div class="tb-code-line-emphasize tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;<span class="tb-hl-tag">div&nbsp;</span><span class="tb-hl-attr-name">ref</span>={props.rootRef}<span class="tb-hl-tag">&nbsp;</span><span class="tb-hl-attr-name">style</span>={{color: props.component.state.color}}&gt;</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是 Textbus 富文本编辑器，我是 {props.component.name} 组件！</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/<span class="tb-hl-tag">div</span>&gt;</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;)</div><div class="tb-code-line">&nbsp;&nbsp;}</div><div class="tb-code-line">}</div></div><span class="tb-pre-lang">Tsx</span></div></pre><pre lang="TypeScript" theme="starry" line-number class="tb-pre"><div class="tb-pre-content"><div style="width:2.5em" class="tb-code-line-number-bg"></div><div class="tb-code-content tb-color-content-highlight"><div class="tb-code-line"><span class="tb-hl-keyword">const</span>&nbsp;rootModel = rootComponent.<span class="tb-hl-function">createInstance</span>(textbus, {</div><div class="tb-code-line-emphasize tb-code-line">&nbsp;&nbsp;state: {</div><div class="tb-code-line-emphasize tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;color:&nbsp;<span class="tb-hl-string">'red'</span></div><div class="tb-code-line-emphasize tb-code-line">&nbsp;&nbsp;}</div><div class="tb-code-line">})</div><div class="tb-code-line"><br></div><div class="tb-code-line">textbus.<span class="tb-hl-function">render</span>(rootModel)</div></div><span class="tb-pre-lang">TypeScript</span></div></pre>
<p>我们在创建 rootComponent 实例时，通过 state 属性传入了一个配置对象，该对象会作为组件的状态保存在 rootComponent 实例中。在渲染时，我们读取了当前组件的 state.color 属性，并赋值给了 div 元素的 style 属性。这样，rootComponent 就有了动态数据的能力。</p>
<p>你可以传入任意的可序列化的数据作为组件的状态以满足不同的需求！</p>
<h3>组件状态管理</h3>
<p>我们不仅可以在一个组件创建时传入 state，我们还可以对已有 state 的组件进行状态更改，这非常的简单，只需要调用组件的 updateState() 方法即可。</p><pre lang="Tsx" theme="starry" line-number class="tb-pre"><div class="tb-pre-content"><div style="width:2.5em" class="tb-code-line-number-bg"></div><div class="tb-code-content tb-color-content-highlight"><div class="tb-code-line"><span class="tb-hl-keyword">export</span>&nbsp;<span class="tb-hl-keyword">const</span>&nbsp;RootComponentView = (props: ViewComponentProps&lt;<span class="tb-hl-keyword">typeof</span>&nbsp;rootComponent&gt;) =&gt; {</div><div class="tb-code-line-emphasize tb-code-line">&nbsp;&nbsp;<span class="tb-hl-keyword">function</span>&nbsp;<span class="tb-hl-function">toGreen</span>() {</div><div class="tb-code-line-emphasize tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;props.component.<span class="tb-hl-function">updateState</span>(draft =&gt; {</div><div class="tb-code-line-emphasize tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;draft.color =&nbsp;<span class="tb-hl-string">'green'</span></div><div class="tb-code-line-emphasize tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;})</div><div class="tb-code-line-emphasize tb-code-line">&nbsp;&nbsp;}</div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-keyword">return</span>&nbsp;() =&gt; {</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-keyword">return</span>&nbsp;(</div><div class="tb-code-line-emphasize tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;<span class="tb-hl-tag">div&nbsp;</span><span class="tb-hl-attr-name">ref</span>={props.rootRef}<span class="tb-hl-tag">&nbsp;</span><span class="tb-hl-attr-name">onClick</span>={toGreen}<span class="tb-hl-tag">&nbsp;</span><span class="tb-hl-attr-name">style</span>={{color: props.component.state.color}}&gt;</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是 Textbus 富文本编辑器，我是 {props.component.name} 组件！</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/<span class="tb-hl-tag">div</span>&gt;</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;)</div><div class="tb-code-line">&nbsp;&nbsp;}</div><div class="tb-code-line">}</div></div><span class="tb-pre-lang">Tsx</span></div></pre>
<p>在上面的示例中，当我们点击 div 时，通过当前组件的 updateState 方法更改了组件状态的 color 值。</p>
<p>updateState方法会传入一个 draft 对象，该对象是对组件 state 的代理，你可以在此更改组件的任意状态。Textbus 会记录这些状态的更改，并在历史还原时，回退到改变之前的状态。</p>
<tb-alert data-type="info" class="tb-alert tb-alert-info">
  <div>Textbus 组件的状态管理是由&nbsp;<a target="_blank" href="https://github.com/immerjs/immer">immer</a>&nbsp;实现的，你可以参考 immer 的相关文档。</div>
</tb-alert>
<p>请不要将函数或其它大对象用于 Textbus 组件的状态中，这些不可序列化的数据，将不能正常回退和在线协作。</p>
<h2>可编辑组件</h2>
<p>前面文档中的组件只是承担了状态管理的作用，我们只能更改其状态，并渲染在文档中。但富文本最核心的编辑能力，则需要借助插槽才能完成。</p>
<p>在 Textbus 组件中，我们可以给一个组件添加一个或多个插槽。插槽的作用类似于我们给一个 DOM 元素添加了 contenteditable="true" 一样，我们可以对插槽中的内容进行编辑、修改，还可以通过历史记录回退我们编辑的内容。</p>
<h3>插槽</h3>
<p>什么是插槽？</p>
<p>插槽在 Textbus 中表示一段可编辑的文档，就像我们给一个 DIV 元素添加了 contenteditable="true" 一样。不同的是，Textbus 中的插槽的编辑行为完全由我们控制，而浏览器原生的 contenteditable 的行为是不可控的。</p>
<p>要让组件支持插槽，只需要在组件创建时，在配置项传入一个插槽实例即可。</p><pre lang="Tsx" theme="starry" line-number class="tb-pre"><div class="tb-pre-content"><div style="width:2.5em" class="tb-code-line-number-bg"></div><div class="tb-code-content tb-color-content-highlight"><div class="tb-code-line"><span class="tb-hl-comment">// # root.component.tsx</span></div><div class="tb-code-line-emphasize tb-code-line"><span class="tb-hl-keyword">import</span>&nbsp;{ defineComponent, Slot, ContextType, createVNode }&nbsp;<span class="tb-hl-keyword">from</span>&nbsp;<span class="tb-hl-string">'@textbus/core'</span></div><div class="tb-code-line-emphasize tb-code-line"><span class="tb-hl-keyword">import</span>&nbsp;{ ViewAdapter }&nbsp;<span class="tb-hl-keyword">from</span>&nbsp;<span class="tb-hl-string">'@textbus/platform-browser'</span></div><div class="tb-code-line-emphasize tb-code-line"><span class="tb-hl-keyword">import</span>&nbsp;{ inject }&nbsp;<span class="tb-hl-keyword">from</span>&nbsp;<span class="tb-hl-string">'@viewfly/core'</span></div><div class="tb-code-line"><span class="tb-hl-keyword">import</span>&nbsp;{ ViewComponentProps }&nbsp;<span class="tb-hl-keyword">from</span>&nbsp;<span class="tb-hl-string">'@textbus/adapter-viewfly'</span></div><div class="tb-code-line"><br></div><div class="tb-code-line"><span class="tb-hl-comment">// 定义 Textbus 根组件数据模型</span></div><div class="tb-code-line"><span class="tb-hl-keyword">const</span>&nbsp;rootComponent =&nbsp;<span class="tb-hl-function">defineComponent</span>({</div><div class="tb-code-line">&nbsp;&nbsp;name:&nbsp;<span class="tb-hl-string">'RootComponent'</span>,</div><div class="tb-code-line">&nbsp;&nbsp;type: ContentType.BlockComponent</div><div class="tb-code-line">})</div><div class="tb-code-line"><span class="tb-hl-comment">// 创建 RootComponentView 组件用于渲染 Textbus 根组件</span></div><div class="tb-code-line"><span class="tb-hl-keyword">const</span>&nbsp;RootComponentView = (props: ViewComponentProps&lt;<span class="tb-hl-keyword">typeof</span>&nbsp;rootComponent&gt;) =&gt; {</div><div class="tb-code-line-emphasize tb-code-line">&nbsp;&nbsp;<span class="tb-hl-comment">// 获取视图适配器，用于渲染插槽</span></div><div class="tb-code-line-emphasize tb-code-line">&nbsp;&nbsp;<span class="tb-hl-keyword">const</span>&nbsp;adapter =&nbsp;<span class="tb-hl-function">inject</span>(ViewAdapter)</div><div class="tb-code-line-emphasize tb-code-line">&nbsp;&nbsp;<span class="tb-hl-keyword">return</span>&nbsp;() =&gt; {</div><div class="tb-code-line-emphasize tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-comment">// 由于我们在上面只给 rootComponent 组件提供了一个插槽，这里获取根组件的第一个插槽即可</span></div><div class="tb-code-line-emphasize tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-keyword">const</span>&nbsp;slot = props.component.slots.<span class="tb-hl-function">get</span>(<span class="tb-hl-number">0</span>)!</div><div class="tb-code-line-emphasize tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-keyword">return</span>&nbsp;&lt;<span class="tb-hl-tag">div&nbsp;</span><span class="tb-hl-attr-name">ref</span>={props.rootRef}&gt;</div><div class="tb-code-line-emphasize tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;<span class="tb-hl-tag">div</span>&gt;这是 Textbus 富文本编辑器，我是 {props.component.name} 组件！&lt;/<span class="tb-hl-tag">div</span>&gt;</div><div class="tb-code-line-emphasize tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</div><div class="tb-code-line-emphasize tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-comment">// 通过适配器的 slotRender 方法，渲染插槽的内容</span></div><div class="tb-code-line-emphasize tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;adapter.<span class="tb-hl-function">slotRender</span>(slot, children =&gt; {</div><div class="tb-code-line-emphasize tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-comment">// 使用 Textbus 内置的 createVNode 方法，渲染插槽的根节点 p</span></div><div class="tb-code-line-emphasize tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-keyword">return</span>&nbsp;<span class="tb-hl-function">createVNode</span>(<span class="tb-hl-string">'div'</span>,&nbsp;<span class="tb-hl-keyword">null</span>, children)</div><div class="tb-code-line-emphasize tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;})</div><div class="tb-code-line-emphasize tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</div><div class="tb-code-line-emphasize tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&lt;/<span class="tb-hl-tag">div</span>&gt;</div><div class="tb-code-line-emphasize tb-code-line">&nbsp;&nbsp;}</div><div class="tb-code-line">}</div></div><span class="tb-pre-lang">Tsx</span></div></pre><pre lang="TypeScript" theme="starry" line-number class="tb-pre"><div class="tb-pre-content"><div style="width:2.5em" class="tb-code-line-number-bg"></div><div class="tb-code-content tb-color-content-highlight"><div class="tb-code-line"><span class="tb-hl-keyword">const</span>&nbsp;rootModel = rootComponent.<span class="tb-hl-function">createInstance</span>(textbus, {</div><div class="tb-code-line">&nbsp;&nbsp;state: {</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;color:&nbsp;<span class="tb-hl-string">'red'</span></div><div class="tb-code-line">&nbsp;&nbsp;},</div><div class="tb-code-line-emphasize tb-code-line">&nbsp;&nbsp;slots: [</div><div class="tb-code-line-emphasize tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-keyword">new</span>&nbsp;<span class="tb-hl-class-name">Slot</span>([ContentType.Text])</div><div class="tb-code-line-emphasize tb-code-line">&nbsp;&nbsp;]</div><div class="tb-code-line">})</div><div class="tb-code-line"><br></div><div class="tb-code-line">textbus.<span class="tb-hl-function">render</span>(rootModel)</div></div><span class="tb-pre-lang">TypeScript</span></div></pre>
<p>我们再次运行项目，如无意外，你会在页面中看到一个可编辑的 div 标签了。</p>
<h2>子组件</h2>
<p>目前，我们实现的编辑器只能支持文本输入和简单的换行，而正常的文档往往是由多个段落组成，要实现多段落功能，我们还需要再编写一个段落组件。</p><pre lang="Tsx" theme="starry" line-number class="tb-pre"><div class="tb-pre-content"><div style="width:2.5em" class="tb-code-line-number-bg"></div><div class="tb-code-content"><div class="tb-code-line"><span class="tb-hl-comment">// # paragraph.component.tsx</span></div><div class="tb-code-line"><span class="tb-hl-keyword">import</span>&nbsp;{ defineComponent, ContentType, createVNode }&nbsp;<span class="tb-hl-keyword">from</span>&nbsp;<span class="tb-hl-string">'@textbus/core'</span></div><div class="tb-code-line"><span class="tb-hl-keyword">import</span>&nbsp;{ ViewComponentProps }&nbsp;<span class="tb-hl-keyword">from</span>&nbsp;<span class="tb-hl-string">'@textbus/adapter-viewfly'</span></div><div class="tb-code-line"><span class="tb-hl-keyword">import</span>&nbsp;{ ViewAdapter }&nbsp;<span class="tb-hl-keyword">from</span>&nbsp;<span class="tb-hl-string">'@textbus/platform-browser'</span></div><div class="tb-code-line"><span class="tb-hl-keyword">import</span>&nbsp;{ inject }&nbsp;<span class="tb-hl-keyword">from</span>&nbsp;<span class="tb-hl-string">'@viewfly/core'</span></div><div class="tb-code-line"><br></div><div class="tb-code-line"><span class="tb-hl-keyword">export</span>&nbsp;<span class="tb-hl-keyword">const</span>&nbsp;paragraphComponent =&nbsp;<span class="tb-hl-function">defineComponent</span>({</div><div class="tb-code-line">&nbsp;&nbsp;name:&nbsp;<span class="tb-hl-string">'ParagraphComponent'</span>,</div><div class="tb-code-line">&nbsp;&nbsp;type: ContentType.BlockComponent</div><div class="tb-code-line">})</div><div class="tb-code-line"><br></div><div class="tb-code-line"><span class="tb-hl-keyword">export</span>&nbsp;<span class="tb-hl-keyword">const</span>&nbsp;ParagraphComponentView = (props: ViewComponentProps&lt;<span class="tb-hl-keyword">typeof</span>&nbsp;paragraphComponent&gt;) {</div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-keyword">const</span>&nbsp;adapter =&nbsp;<span class="tb-hl-function">inject</span>(ViewAdapter)</div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-keyword">return</span>&nbsp;() =&gt; {</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-keyword">return</span>&nbsp;(</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;<span class="tb-hl-tag">div&nbsp;</span><span class="tb-hl-attr-name">data-component</span>={props.component.name}<span class="tb-hl-tag">&nbsp;</span><span class="tb-hl-attr-name">ref</span>={props.rootRef}&gt;</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;adapter.<span class="tb-hl-function">slotRender</span>(props.component.slots.first!, children =&gt; {</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-keyword">return</span>&nbsp;<span class="tb-hl-function">createVNode</span>(<span class="tb-hl-string">'p'</span>,&nbsp;<span class="tb-hl-keyword">null</span>, children)</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;})</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/<span class="tb-hl-tag">div</span>&gt;</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;)</div><div class="tb-code-line">&nbsp;&nbsp;}</div><div class="tb-code-line">}</div></div><span class="tb-pre-lang">Tsx</span></div></pre>
<p>将我们的段落组件注册到视图适配器。</p><pre lang="TypeScript" theme="starry" line-number class="tb-pre"><div class="tb-pre-content"><div style="width:2.5em" class="tb-code-line-number-bg"></div><div class="tb-code-content tb-color-content-highlight"><div class="tb-code-line"><span class="tb-hl-comment">// # editor.ts</span></div><div class="tb-code-line-emphasize tb-code-line"><span class="tb-hl-keyword">import</span>&nbsp;{ paragraphComponent, ParagraphComponentView }&nbsp;<span class="tb-hl-keyword">from</span>&nbsp;<span class="tb-hl-string">'./paragraph.component'</span></div><div class="tb-code-line"><br></div><div class="tb-code-line"><span class="tb-hl-keyword">const</span>&nbsp;adapter =&nbsp;<span class="tb-hl-keyword">new</span>&nbsp;<span class="tb-hl-class-name">Adapter</span>({</div><div class="tb-code-line">&nbsp;&nbsp;[rootComponent.name]: RootComponentView,</div><div class="tb-code-line-emphasize tb-code-line">&nbsp;&nbsp;[paragraphComponent.name]: ParagraphComponentView</div><div class="tb-code-line">}, (host, root) =&gt; {</div><div class="tb-code-line">&nbsp;&nbsp;...</div><div class="tb-code-line">})</div></div><span class="tb-pre-lang">TypeScript</span></div></pre>
<p>一个文档往往都是从一个空文档开始，再根据用户的输入，生成段落、格式等等，为了尽量靠近真实环境，我们要对 rootComponent 做一些调整，把不需要的标签删除掉。</p><pre lang="Tsx" theme="starry" line-number class="tb-pre"><div class="tb-pre-content"><div style="width:2.5em" class="tb-code-line-number-bg"></div><div class="tb-code-content"><div class="tb-code-line"><span class="tb-hl-comment">// # root.component.tsx</span></div><div class="tb-code-line"><br></div><div class="tb-code-line"><span class="tb-hl-keyword">const</span>&nbsp;RootComponentView = (props: ViewComponentProps&lt;<span class="tb-hl-keyword">typeof</span>&nbsp;rootComponent&gt;) =&gt; {</div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-keyword">const</span>&nbsp;adapter =&nbsp;<span class="tb-hl-function">inject</span>(ViewAdapter)</div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-keyword">return</span>&nbsp;() =&gt; {</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-keyword">const</span>&nbsp;slot = props.component.slots.<span class="tb-hl-function">get</span>(<span class="tb-hl-number">0</span>)!</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-keyword">return</span>&nbsp;&lt;<span class="tb-hl-tag">div&nbsp;</span><span class="tb-hl-attr-name">data-component</span>={props.component.name}<span class="tb-hl-tag">&nbsp;</span><span class="tb-hl-attr-name">ref</span>={props.rootRef}&gt;</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-comment">// 通过适配器的 slotRender 方法，渲染插槽的内容</span></div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;adapter.<span class="tb-hl-function">slotRender</span>(slot, children =&gt; {</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-comment">// 使用 Textbus 内置的 createVNode 方法，渲染插槽的根节点 p</span></div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-keyword">return</span>&nbsp;<span class="tb-hl-function">createVNode</span>(<span class="tb-hl-string">'div'</span>,&nbsp;<span class="tb-hl-keyword">null</span>, children)</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;})</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&lt;/<span class="tb-hl-tag">div</span>&gt;</div><div class="tb-code-line">&nbsp;&nbsp;}</div><div class="tb-code-line">}</div></div><span class="tb-pre-lang">Tsx</span></div></pre>
<p>现在我们的 rootComponent 组件基本达到我们的要求了。启动项目，Textbus 会在浏览器中渲染出一个空的 rootComponent 组件，我们可以在中间输入文本、换行等。但实际场景中，我们往往希望把这些文本全都插入在段落中，而不是直接写在根组件内。我们应当如何控制用户的输入并把文字输入到段落中呢？</p>
<h2>组件事件</h2>
<p>为了让 rootComponent 组件的插槽可以插槽段落，我们需要先让它的插槽支持插入 Block 组件。更改 rootComponent 组件的初始化代码。</p><pre lang="TypeScript" theme="starry" line-number class="tb-pre"><div class="tb-pre-content"><div style="width:2.5em" class="tb-code-line-number-bg"></div><div class="tb-code-content tb-color-content-highlight"><div class="tb-code-line"><span class="tb-hl-comment">// # editor.ts</span></div><div class="tb-code-line"><span class="tb-hl-keyword">const</span>&nbsp;rootModel = rootComponent.<span class="tb-hl-function">createInstance</span>(textbus, {</div><div class="tb-code-line">&nbsp;&nbsp;state: {</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;color:&nbsp;<span class="tb-hl-string">'red'</span></div><div class="tb-code-line">&nbsp;&nbsp;},</div><div class="tb-code-line">&nbsp;&nbsp;slots: [</div><div class="tb-code-line-emphasize tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-keyword">new</span>&nbsp;<span class="tb-hl-class-name">Slot</span>([</div><div class="tb-code-line-emphasize tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ContentType.Text,</div><div class="tb-code-line-emphasize tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ContentType.InlineComponent,</div><div class="tb-code-line-emphasize tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ContentType.BlockComponent</div><div class="tb-code-line-emphasize tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;])</div><div class="tb-code-line">&nbsp;&nbsp;]</div><div class="tb-code-line">})</div><div class="tb-code-line"><br></div><div class="tb-code-line">textbus.<span class="tb-hl-function">render</span>(rootModel)</div></div><span class="tb-pre-lang">TypeScript</span></div></pre>
<p>我们的需求是，当用户在 rootComponent 组件的插槽内输入时，我们需要拦截用户的输入，并把输入的结果插入在一个新的段落内，同时还需要把光标也移动到段落内的文字后面。</p>
<p>在 Textbus 中，用户的所有输入、删除等操作都是可控的，我们可以监听相关事件，并定制其功能。要监听用户的输入内容事件，只需要在 Textbus 组件中调用 onContentInsert 勾子即可。</p><pre lang="Tsx" theme="starry" line-number class="tb-pre"><div class="tb-pre-content"><div style="width:2.5em" class="tb-code-line-number-bg"></div><div class="tb-code-content"><div class="tb-code-line"><span class="tb-hl-comment">// # root.component.tsx</span></div><div class="tb-code-line"><span class="tb-hl-keyword">import</span>&nbsp;{ onContentInsert, useContext, Selection, Slot, ContentType }&nbsp;<span class="tb-hl-keyword">from</span>&nbsp;<span class="tb-hl-string">'@textbus/core'</span></div><div class="tb-code-line"><span class="tb-hl-keyword">import</span>&nbsp;{ paragraphComponent }&nbsp;<span class="tb-hl-string">'./paragraph.component'</span></div><div class="tb-code-line"><br></div><div class="tb-code-line"><span class="tb-hl-keyword">export</span>&nbsp;<span class="tb-hl-keyword">const</span>&nbsp;rootComponent =&nbsp;<span class="tb-hl-function">defineComponent</span>({</div><div class="tb-code-line">&nbsp;&nbsp;name:&nbsp;<span class="tb-hl-string">'RootComponent'</span>,</div><div class="tb-code-line">&nbsp;&nbsp;type: ContentType.BlockComponent,</div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-function">setup</span>() {</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-keyword">const</span>&nbsp;selection =&nbsp;<span class="tb-hl-function">useContext</span>(Selection)</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-comment">// 监听内容插入事件</span></div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-function">onContentInsert</span>(ev =&gt; {</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-comment">// 当插入的内容是一个字符串或行内组件时，我们将创建新的段落</span></div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-keyword">if</span>&nbsp;(<span class="tb-hl-keyword">typeof</span>&nbsp;ev.data.content ===&nbsp;<span class="tb-hl-string">'string'</span>&nbsp;|| ev.data.content.type !== ContentType.BlockComponent) {</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-comment">// 创建新的插槽，并把内容插入在新插槽内</span></div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-keyword">const</span>&nbsp;slot =&nbsp;<span class="tb-hl-keyword">new</span>&nbsp;<span class="tb-hl-class-name">Slot</span>([</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ContentType.Text,</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ContentType.InlineComponent</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;])</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;slot.<span class="tb-hl-function">insert</span>(ev.data.content)</div><div class="tb-code-line"><br></div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-comment">// 创建新的段落组件，并把插槽传给段落组件</span></div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-keyword">const</span>&nbsp;p = paragraphComponent.<span class="tb-hl-function">createInstance</span>(injector, {</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;slots: [slot]</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;})</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-comment">// 在 rootComponent 的插槽内插入新段落</span></div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ev.target.<span class="tb-hl-function">insert</span>(p)</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-comment">// 设置光标为段落组件插槽的索引位置</span></div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;selection.<span class="tb-hl-function">setPosition</span>(slot, slot.index)</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-comment">// 阻止默认的插入事件</span></div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ev.<span class="tb-hl-function">preventDefault</span>()</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;})</div><div class="tb-code-line">&nbsp;&nbsp;}</div><div class="tb-code-line">})</div></div><span class="tb-pre-lang">Tsx</span></div></pre>
<p>现在，当我们再在 rootComponent 组件内输入时，你将会发现我们输入的内容全都到段落里面了。但当我们在段落内换行内，我们发现此时的换行还如原来一样，只是增加了一个 br 标签。在大多数场景中，我们需要换行时开启一个新段落。让我们对段落的换行行为再做一些定制。</p><pre lang="Tsx" theme="starry" line-number class="tb-pre"><div class="tb-pre-content"><div style="width:2.5em" class="tb-code-line-number-bg"></div><div class="tb-code-content tb-color-content-highlight"><div class="tb-code-line"><span class="tb-hl-comment">// # paragraph.component.tsx</span></div><div class="tb-code-line-emphasize tb-code-line"><span class="tb-hl-keyword">import</span>&nbsp;{ defineComponent, ContentType, createVNode, onBreak, Slot, Seletion, useSelf, Commander }&nbsp;<span class="tb-hl-keyword">from</span>&nbsp;<span class="tb-hl-string">'@textbus/core'</span></div><div class="tb-code-line"><span class="tb-hl-keyword">import</span>&nbsp;{ ViewComponentProps }&nbsp;<span class="tb-hl-keyword">from</span>&nbsp;<span class="tb-hl-string">'@textbus/adapter-viewfly'</span></div><div class="tb-code-line"><span class="tb-hl-keyword">import</span>&nbsp;{ ViewAdapter }&nbsp;<span class="tb-hl-keyword">from</span>&nbsp;<span class="tb-hl-string">'@textbus/platform-browser'</span></div><div class="tb-code-line"><span class="tb-hl-keyword">import</span>&nbsp;{ inject }&nbsp;<span class="tb-hl-keyword">from</span>&nbsp;<span class="tb-hl-string">'@viewfly/core'</span></div><div class="tb-code-line"><br></div><div class="tb-code-line"><span class="tb-hl-keyword">export</span>&nbsp;<span class="tb-hl-keyword">const</span>&nbsp;paragraphComponent =&nbsp;<span class="tb-hl-function">defineComponent</span>({</div><div class="tb-code-line">&nbsp;&nbsp;name:&nbsp;<span class="tb-hl-string">'ParagraphComponent'</span>,</div><div class="tb-code-line">&nbsp;&nbsp;type: ContentType.BlockComponent,</div><div class="tb-code-line-emphasize tb-code-line">&nbsp;&nbsp;<span class="tb-hl-function">setup</span>() {</div><div class="tb-code-line-emphasize tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-keyword">const</span>&nbsp;self =&nbsp;<span class="tb-hl-function">useSelf</span>()</div><div class="tb-code-line-emphasize tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-keyword">const</span>&nbsp;commander =&nbsp;<span class="tb-hl-function">useContext</span>(Commander)</div><div class="tb-code-line-emphasize tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-keyword">const</span>&nbsp;selection =&nbsp;<span class="tb-hl-function">useContext</span>(Selection)</div><div class="tb-code-line-emphasize tb-code-line"><br></div><div class="tb-code-line-emphasize tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-comment">// 监听换行事件</span></div><div class="tb-code-line-emphasize tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-function">onBreak</span>(ev =&gt; {</div><div class="tb-code-line-emphasize tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-comment">// 剪切光标后的内容，并插入在新插槽内</span></div><div class="tb-code-line-emphasize tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-keyword">const</span>&nbsp;afterContentDelta = ev.target.<span class="tb-hl-function">cut</span>(ev.data.index).<span class="tb-hl-function">toDelta</span>()</div><div class="tb-code-line-emphasize tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-keyword">const</span>&nbsp;slot =&nbsp;<span class="tb-hl-keyword">new</span>&nbsp;<span class="tb-hl-class-name">Slot</span>([</div><div class="tb-code-line-emphasize tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ContentType.Text,</div><div class="tb-code-line-emphasize tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ContentType.InlineComponent</div><div class="tb-code-line-emphasize tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;])</div><div class="tb-code-line-emphasize tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;slot.<span class="tb-hl-function">insertDelta</span>(afterContentDelta)</div><div class="tb-code-line-emphasize tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-comment">// 创建新段落，并传入新插槽</span></div><div class="tb-code-line-emphasize tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-keyword">const</span>&nbsp;nextParagraph = paragraphComponent.<span class="tb-hl-function">createInstance</span>(injector, {</div><div class="tb-code-line-emphasize tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;slots: [slot]</div><div class="tb-code-line-emphasize tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;})</div><div class="tb-code-line-emphasize tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-comment">// 把新段落插入在当前段落后</span></div><div class="tb-code-line-emphasize tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;commander.<span class="tb-hl-function">insertAfter</span>(nextParagraph, self)</div><div class="tb-code-line-emphasize tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-comment">// 设置光标为新段落的开始</span></div><div class="tb-code-line-emphasize tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;selection.<span class="tb-hl-function">setPosition</span>(slot,&nbsp;<span class="tb-hl-number">0</span>)</div><div class="tb-code-line-emphasize tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-comment">// 阻止默认的折行行为</span></div><div class="tb-code-line-emphasize tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ev.<span class="tb-hl-function">preventDefault</span>()</div><div class="tb-code-line-emphasize tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;})</div><div class="tb-code-line-emphasize tb-code-line">&nbsp;&nbsp;}</div><div class="tb-code-line">})</div></div><span class="tb-pre-lang">Tsx</span></div></pre>
<p>至此，当我们在 rootComponent 组件输入时，我们将创建一个新的段落，我们可以在段落内正常的输入。当我们在段落内换行时，可以开启一个新的段落。我们基础版的编辑器就算完成了。</p>
<h2>多插槽组件</h2>
<p>前面我们创建的 rootComponent 和 paragraphComponent 都是单插槽组件。我们还可以创建多插槽组件，如列表、表格等，我们以列表为例，一个 ul 下可能包含多个 li。</p><pre lang="Tsx" theme="starry" line-number class="tb-pre"><div class="tb-pre-content"><div style="width:2.5em" class="tb-code-line-number-bg"></div><div class="tb-code-content"><div class="tb-code-line"><span class="tb-hl-comment">// # list.component.ts</span></div><div class="tb-code-line"><span class="tb-hl-keyword">import</span>&nbsp;{ defineComponent, ContentType, Selection, Slot, useContext, onBreak, createVNode }&nbsp;<span class="tb-hl-keyword">from</span>&nbsp;<span class="tb-hl-string">'@textbus/core'</span></div><div class="tb-code-line"><span class="tb-hl-keyword">import</span>&nbsp;{ ViewComponentProps }&nbsp;<span class="tb-hl-keyword">from</span>&nbsp;<span class="tb-hl-string">'@textbus/adapter-viewfly'</span></div><div class="tb-code-line"><span class="tb-hl-keyword">import</span>&nbsp;{ ViewAdapter }&nbsp;<span class="tb-hl-keyword">from</span>&nbsp;<span class="tb-hl-string">'@textbus/platform-browser'</span></div><div class="tb-code-line"><span class="tb-hl-keyword">import</span>&nbsp;{ inject }&nbsp;<span class="tb-hl-keyword">from</span>&nbsp;<span class="tb-hl-string">'@viewfly/core'</span></div><div class="tb-code-line"><br></div><div class="tb-code-line"><span class="tb-hl-keyword">import</span>&nbsp;{ paragraphComponent }&nbsp;<span class="tb-hl-keyword">from</span>&nbsp;<span class="tb-hl-string">'./paragraph.component'</span></div><div class="tb-code-line"><br></div><div class="tb-code-line"><span class="tb-hl-keyword">export</span>&nbsp;<span class="tb-hl-keyword">const</span>&nbsp;listComponent =&nbsp;<span class="tb-hl-function">defineComponent</span>({</div><div class="tb-code-line">&nbsp;&nbsp;name:&nbsp;<span class="tb-hl-string">'ListComponent'</span>,</div><div class="tb-code-line">&nbsp;&nbsp;type: ContentType.BlockComponent,</div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-function">setup</span>() {</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-keyword">const</span>&nbsp;selection =&nbsp;<span class="tb-hl-function">useContext</span>(Seletion)</div><div class="tb-code-line"><br></div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-function">onBreak</span>(ev =&gt; {</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-keyword">if</span>&nbsp;(ev.target.isEmpty &amp;&amp; ev.target === slots.last) {</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-keyword">const</span>&nbsp;paragraph = paragraphComponent.<span class="tb-hl-function">createInstance</span>(injector, {</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;slots: [</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-keyword">new</span>&nbsp;<span class="tb-hl-class-name">Slot</span>([ContentType.Text, ContentType.InlineComponent])</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;]</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;})</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-keyword">const</span>&nbsp;parentComponent = selection.commonAncestorComponent!</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-keyword">const</span>&nbsp;parentSlot = parentComponent.parent!</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-keyword">const</span>&nbsp;index = parentSlot.<span class="tb-hl-function">indexOf</span>(parentComponent)</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parentSlot.<span class="tb-hl-function">retain</span>(index +&nbsp;<span class="tb-hl-number">1</span>)</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-keyword">if</span>&nbsp;(slots.length &gt;&nbsp;<span class="tb-hl-number">1</span>) {</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;slots.<span class="tb-hl-function">remove</span>(slots.last)</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parentSlot.<span class="tb-hl-function">insert</span>(paragraph)</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;selection.<span class="tb-hl-function">setPosition</span>(paragraph.slots.<span class="tb-hl-function">get</span>(<span class="tb-hl-number">0</span>)!,&nbsp;<span class="tb-hl-number">0</span>)</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ev.<span class="tb-hl-function">preventDefault</span>()</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-keyword">return</span></div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-keyword">const</span>&nbsp;nextLi = ev.target.<span class="tb-hl-function">cut</span>(ev.data.index)</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;slots.<span class="tb-hl-function">insertAfter</span>(nextLi, ev.target)</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;selection.<span class="tb-hl-function">setPosition</span>(nextLi,&nbsp;<span class="tb-hl-number">0</span>)</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ev.<span class="tb-hl-function">preventDefault</span>()</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;})</div><div class="tb-code-line">&nbsp;&nbsp;}</div><div class="tb-code-line">})</div><div class="tb-code-line"><br></div><div class="tb-code-line"><span class="tb-hl-keyword">export</span>&nbsp;<span class="tb-hl-keyword">const</span>&nbsp;ListComponentView = (props: ViewComponentProps&lt;<span class="tb-hl-keyword">typeof</span>&nbsp;listComponent&gt;) {</div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-keyword">const</span>&nbsp;adapter =&nbsp;<span class="tb-hl-function">inject</span>(ViewAdapter)</div><div class="tb-code-line"><br></div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-keyword">return</span>&nbsp;() =&gt; {</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-keyword">const</span>&nbsp;component = props.component</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-keyword">return</span>&nbsp;(</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;<span class="tb-hl-tag">ul&nbsp;</span><span class="tb-hl-attr-name">ref</span>={props.rootRef}<span class="tb-hl-tag">&nbsp;</span><span class="tb-hl-attr-name">data-component</span>={component.name}&gt;</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;component.slots.<span class="tb-hl-function">toArray</span>().<span class="tb-hl-function">map</span>(slot =&gt; {</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-keyword">return</span>&nbsp;adapter.<span class="tb-hl-function">slotRender</span>(slot, children =&gt; {</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-keyword">return</span>&nbsp;<span class="tb-hl-function">createVNode</span>(<span class="tb-hl-string">'li'</span>,&nbsp;<span class="tb-hl-keyword">null</span>, children)</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;})</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;})</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/<span class="tb-hl-tag">ul</span>&gt;</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;)</div><div class="tb-code-line">&nbsp;&nbsp;}</div><div class="tb-code-line">}</div></div><span class="tb-pre-lang">Tsx</span></div></pre>
<p>我们完成了 listComponent 的开发，并且，当我们在列表内换行时，如果是末尾有连续两个 li，将跳出列表，并创建一个新的段落。现在，我们把 listComponent 添加到适配器中。</p><pre lang="TypeScript" theme="starry" line-number class="tb-pre"><div class="tb-pre-content"><div style="width:2.5em" class="tb-code-line-number-bg"></div><div class="tb-code-content tb-color-content-highlight"><div class="tb-code-line"><span class="tb-hl-comment">// # editor.ts</span></div><div class="tb-code-line-emphasize tb-code-line"><span class="tb-hl-keyword">import</span>&nbsp;{ listComponent, ListComponentView }&nbsp;<span class="tb-hl-keyword">from</span>&nbsp;<span class="tb-hl-string">'./list.component'</span></div><div class="tb-code-line"><br></div><div class="tb-code-line"><span class="tb-hl-keyword">const</span>&nbsp;adapter =&nbsp;<span class="tb-hl-keyword">new</span>&nbsp;<span class="tb-hl-class-name">Adapter</span>({</div><div class="tb-code-line">&nbsp;&nbsp;[rootComponent.name]: RootComponentView,</div><div class="tb-code-line">&nbsp;&nbsp;[paragraphComponent.name]: ParagraphComponentView,</div><div class="tb-code-line-emphasize tb-code-line">&nbsp;&nbsp;[listComponent.name]: ListComponentView</div><div class="tb-code-line">}, (host, root) =&gt; {</div><div class="tb-code-line">&nbsp;&nbsp;...</div><div class="tb-code-line">})</div><div class="tb-code-line"><br></div></div><span class="tb-pre-lang">TypeScript</span></div></pre>
<tb-alert data-type="default" class="tb-alert tb-alert-default">
  <div>我们可以先忽略 listComponent 组件的实现细节，可以等学习了后面组件更多的使用细节再回头来看。</div>
</tb-alert>
<h3>Markdown 语法支持</h3>
<p>我们前面创建了 listComponent 组件，但目前我们没有任何方法可以在文档中插入一个 listComponent 组件实例。</p>
<p>Textbus 支持在组件配置项中直接声明语法转换配置。我们可以定义任意的语法转换实现，这里我们以 Markdown 语法转换为列表为例：</p><pre lang="Tsx" theme="starry" line-number class="tb-pre"><div class="tb-pre-content"><div style="width:2.5em" class="tb-code-line-number-bg"></div><div class="tb-code-content tb-color-content-highlight"><div class="tb-code-line"><span class="tb-hl-comment">// # list.component.ts</span></div><div class="tb-code-line"><span class="tb-hl-keyword">import</span>&nbsp;{ defineComponent, ContentType, Selection, Slot, useContext, onBreak, createVNode }&nbsp;<span class="tb-hl-keyword">from</span>&nbsp;<span class="tb-hl-string">'@textbus/core'</span></div><div class="tb-code-line"><span class="tb-hl-keyword">import</span>&nbsp;{ ViewComponentProps }&nbsp;<span class="tb-hl-keyword">from</span>&nbsp;<span class="tb-hl-string">'@textbus/adapter-viewfly'</span></div><div class="tb-code-line"><span class="tb-hl-keyword">import</span>&nbsp;{ ViewAdapter }&nbsp;<span class="tb-hl-keyword">from</span>&nbsp;<span class="tb-hl-string">'@textbus/platform-browser'</span></div><div class="tb-code-line"><span class="tb-hl-keyword">import</span>&nbsp;{ inject }&nbsp;<span class="tb-hl-keyword">from</span>&nbsp;<span class="tb-hl-string">'@viewfly/core'</span></div><div class="tb-code-line"><br></div><div class="tb-code-line"><span class="tb-hl-keyword">import</span>&nbsp;{ paragraphComponent }&nbsp;<span class="tb-hl-keyword">from</span>&nbsp;<span class="tb-hl-string">'./paragraph.component'</span></div><div class="tb-code-line"><br></div><div class="tb-code-line"><span class="tb-hl-keyword">export</span>&nbsp;<span class="tb-hl-keyword">const</span>&nbsp;listComponent =&nbsp;<span class="tb-hl-function">defineComponent</span>({</div><div class="tb-code-line">&nbsp;&nbsp;name:&nbsp;<span class="tb-hl-string">'ListComponent'</span>,</div><div class="tb-code-line">&nbsp;&nbsp;type: ContentType.BlockComponent,</div><div class="tb-code-line-emphasize tb-code-line">&nbsp;&nbsp;<span class="tb-hl-comment">// 添加 zenCoding 配置，Textbus 会在语法匹配时，自动转换为我们的组件</span></div><div class="tb-code-line-emphasize tb-code-line">&nbsp;&nbsp;zenCoding: {</div><div class="tb-code-line-emphasize tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;key:&nbsp;<span class="tb-hl-string">' '</span>,&nbsp;<span class="tb-hl-comment">// 输入空格时触发转换</span></div><div class="tb-code-line-emphasize tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;match: /^([+*])$/,&nbsp;<span class="tb-hl-comment">// 只有在一个空段落开头，且第一个字符中 + 号或 * 号时，才可以转换</span></div><div class="tb-code-line-emphasize tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-function">generateInitData</span>() {</div><div class="tb-code-line-emphasize tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-comment">// 当匹配成功时，创建一个空组件数据并返回，Textbus 会把返回的数据传给当前生成的组件</span></div><div class="tb-code-line-emphasize tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-keyword">return</span>&nbsp;{</div><div class="tb-code-line-emphasize tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;slots: [</div><div class="tb-code-line-emphasize tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-keyword">new</span>&nbsp;<span class="tb-hl-class-name">Slot</span>([</div><div class="tb-code-line-emphasize tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ContentType.Text,</div><div class="tb-code-line-emphasize tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ContentType.InlineComponent</div><div class="tb-code-line-emphasize tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;])</div><div class="tb-code-line-emphasize tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;]</div><div class="tb-code-line-emphasize tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</div><div class="tb-code-line-emphasize tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;}</div><div class="tb-code-line-emphasize tb-code-line">&nbsp;&nbsp;},</div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-function">setup</span>() {</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;...</div><div class="tb-code-line">&nbsp;&nbsp;}</div><div class="tb-code-line">})</div></div><span class="tb-pre-lang">Tsx</span></div></pre>
<p>不要忘了在 Textbus 的配置项中开启 zenCoding。</p><pre lang="TypeScript" theme="starry" line-number class="tb-pre"><div class="tb-pre-content"><div style="width:2.5em" class="tb-code-line-number-bg"></div><div class="tb-code-content tb-color-content-highlight"><div class="tb-code-line"><span class="tb-hl-comment">// 创建 Textbus 实例</span></div><div class="tb-code-line"><span class="tb-hl-keyword">const</span>&nbsp;textbus =&nbsp;<span class="tb-hl-keyword">new</span>&nbsp;<span class="tb-hl-class-name">Textbus</span>({</div><div class="tb-code-line">&nbsp;&nbsp;imports: [</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;browserModule&nbsp;<span class="tb-hl-comment">// 添加浏览器支持模块</span></div><div class="tb-code-line">&nbsp;&nbsp;],</div><div class="tb-code-line-emphasize tb-code-line">&nbsp;&nbsp;zenCoding:&nbsp;<span class="tb-hl-boolean">true</span></div><div class="tb-code-line">})</div></div><span class="tb-pre-lang">TypeScript</span></div></pre>
<p>现在，当我们在文档的空白段落输入 + 号或 * 号并按空格时，便可实时转换为一个列表组件并插入在文档中。</p>
<h2>组件扩展方法</h2>
<p>当我们的组件需要给外部提供数据时，我们可以在 setup 方法内返回任意值给外部使用。我们以列表组件为例，当外部要获取当前组件有多少个列表项时，我们可以对外提供一个 getListCount 方法。</p><pre lang="Tsx" theme="starry" line-number class="tb-pre"><div class="tb-pre-content"><div style="width:2.5em" class="tb-code-line-number-bg"></div><div class="tb-code-content tb-color-content-highlight"><div class="tb-code-line">/ # list.component.ts</div><div class="tb-code-line"><span class="tb-hl-keyword">import</span>&nbsp;{ defineComponent, ContentType, Selection, Slot, useContext, onBreak, createVNode, useSelf }&nbsp;<span class="tb-hl-keyword">from</span>&nbsp;<span class="tb-hl-string">'@textbus/core'</span></div><div class="tb-code-line"><span class="tb-hl-keyword">import</span>&nbsp;{ ViewComponentProps }&nbsp;<span class="tb-hl-keyword">from</span>&nbsp;<span class="tb-hl-string">'@textbus/adapter-viewfly'</span></div><div class="tb-code-line"><span class="tb-hl-keyword">import</span>&nbsp;{ ViewAdapter }&nbsp;<span class="tb-hl-keyword">from</span>&nbsp;<span class="tb-hl-string">'@textbus/platform-browser'</span></div><div class="tb-code-line"><span class="tb-hl-keyword">import</span>&nbsp;{ inject }&nbsp;<span class="tb-hl-keyword">from</span>&nbsp;<span class="tb-hl-string">'@viewfly/core'</span></div><div class="tb-code-line"><br></div><div class="tb-code-line"><span class="tb-hl-keyword">import</span>&nbsp;{ paragraphComponent }&nbsp;<span class="tb-hl-keyword">from</span>&nbsp;<span class="tb-hl-string">'./paragraph.component'</span></div><div class="tb-code-line"><br></div><div class="tb-code-line"><span class="tb-hl-keyword">export</span>&nbsp;<span class="tb-hl-keyword">const</span>&nbsp;listComponent =&nbsp;<span class="tb-hl-function">defineComponent</span>({</div><div class="tb-code-line">&nbsp;&nbsp;name:&nbsp;<span class="tb-hl-string">'ListComponent'</span>,</div><div class="tb-code-line">&nbsp;&nbsp;type: ContentType.BlockComponent,</div><div class="tb-code-line">&nbsp;&nbsp;...</div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-function">setup</span>() {</div><div class="tb-code-line-emphasize tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-keyword">const</span>&nbsp;self =&nbsp;<span class="tb-hl-function">useSelf</span>()</div><div class="tb-code-line-emphasize tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-keyword">return</span>&nbsp;{</div><div class="tb-code-line-emphasize tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-function">getListCount</span>() {</div><div class="tb-code-line-emphasize tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-keyword">return</span>&nbsp;self.slots.length</div><div class="tb-code-line-emphasize tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</div><div class="tb-code-line-emphasize tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;}</div><div class="tb-code-line">&nbsp;&nbsp;}</div><div class="tb-code-line">})</div><div class="tb-code-line"><br></div><div class="tb-code-line"><span class="tb-hl-keyword">const</span>&nbsp;listComponentInstance = listComponent.<span class="tb-hl-function">createInstance</span>(textbus, {...})</div><div class="tb-code-line"><br></div><div class="tb-code-line-emphasize tb-code-line"><span class="tb-hl-comment">// 通过组件实例的 extends 获取 setup 方法的返回值</span></div><div class="tb-code-line-emphasize tb-code-line"><span class="tb-hl-keyword">const</span>&nbsp;count = listComponentInstance.extends.<span class="tb-hl-function">getListCount</span>()</div></div><span class="tb-pre-lang">Tsx</span></div></pre>
<h2>组件数据校验</h2>
<p>在前面的组件示例中，我们无一例外的向组件传入了插槽，在实例化这些插槽时，我们传入了 ContentType.Text 或 ContentType.InlineComponent 等配置，为插槽可插入内容做出了限制，但在实际的场景中，这些插槽的数据可能会传错，或者有缺失，也有可能传多了，比如，给段落组件传入了两个及以上插槽。这将引起不可预期的 bug。我们可以在组件配置选项中，对这些数据进行校验，以确保组件数据的正确性。</p>
<p>我们以段落组件的校验为例：</p><pre lang="Tsx" theme="starry" line-number class="tb-pre"><div class="tb-pre-content"><div style="width:2.5em" class="tb-code-line-number-bg"></div><div class="tb-code-content tb-color-content-highlight"><div class="tb-code-line"><span class="tb-hl-comment">// # paragraph.component.tsx</span></div><div class="tb-code-line"><span class="tb-hl-keyword">import</span>&nbsp;{ defineComponent, ContentType, createVNode, onBreak, Slot, Seletion, useSelf, Commander, ComponentInitData, Textbus }&nbsp;<span class="tb-hl-keyword">from</span>&nbsp;<span class="tb-hl-string">'@textbus/core'</span></div><div class="tb-code-line"><span class="tb-hl-keyword">import</span>&nbsp;{ ViewComponentProps }&nbsp;<span class="tb-hl-keyword">from</span>&nbsp;<span class="tb-hl-string">'@textbus/adapter-viewfly'</span></div><div class="tb-code-line"><span class="tb-hl-keyword">import</span>&nbsp;{ ViewAdapter }&nbsp;<span class="tb-hl-keyword">from</span>&nbsp;<span class="tb-hl-string">'@textbus/platform-browser'</span></div><div class="tb-code-line"><span class="tb-hl-keyword">import</span>&nbsp;{ inject }&nbsp;<span class="tb-hl-keyword">from</span>&nbsp;<span class="tb-hl-string">'@viewfly/core'</span></div><div class="tb-code-line"><br></div><div class="tb-code-line"><span class="tb-hl-keyword">export</span>&nbsp;<span class="tb-hl-keyword">const</span>&nbsp;paragraphComponent =&nbsp;<span class="tb-hl-function">defineComponent</span>({</div><div class="tb-code-line">&nbsp;&nbsp;name:&nbsp;<span class="tb-hl-string">'ParagraphComponent'</span>,</div><div class="tb-code-line">&nbsp;&nbsp;type: ContentType.BlockComponent,</div><div class="tb-code-line-emphasize tb-code-line">&nbsp;&nbsp;<span class="tb-hl-function">validate</span>(textbus: Textbus, initData?: ComponentInitData) {</div><div class="tb-code-line-emphasize tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-keyword">return</span>&nbsp;{</div><div class="tb-code-line-emphasize tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;slots: [initData?.slots?.[<span class="tb-hl-number">0</span>] ||&nbsp;<span class="tb-hl-keyword">new</span>&nbsp;<span class="tb-hl-class-name">Slot</span>([ContentType.Text, ContentType.InlineComponent])]</div><div class="tb-code-line-emphasize tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;}</div><div class="tb-code-line-emphasize tb-code-line">&nbsp;&nbsp;},</div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-function">setup</span>() {</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;...</div><div class="tb-code-line">&nbsp;&nbsp;}</div><div class="tb-code-line">})</div></div><span class="tb-pre-lang">Tsx</span></div></pre>
<p>我们对段落组件的初始数据进行了基本的验证，当初始数据的插槽配置项内有插槽时，我们只使用第一个插槽。如果没有，则创建一个插槽，确保数据的正确。</p>
<p>如果有必要，我们还可以根据做进一步的更详细校验。</p>
<h2>插槽集</h2>
<p>一个组件可以没有插槽，也可以有任意多个插槽，我们可以根据自己的需要增加或删除插槽。</p>
<p>获取组件的插槽只需要在 setup 函数内，调用获取组件的实例，然后访问当前组件的插槽即可。</p><pre lang="TypeScript" theme="starry" line-number class="tb-pre"><div class="tb-pre-content"><div style="width:2.5em" class="tb-code-line-number-bg"></div><div class="tb-code-content"><div class="tb-code-line"><span class="tb-hl-keyword">import</span>&nbsp;{ defineComponent, useSelf }&nbsp;<span class="tb-hl-keyword">from</span>&nbsp;<span class="tb-hl-string">'@textbus/core'</span></div><div class="tb-code-line"><span class="tb-hl-keyword">const</span>&nbsp;component =&nbsp;<span class="tb-hl-function">defineComponent</span>({</div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-function">setup</span>() {</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-keyword">const</span>&nbsp;self =&nbsp;<span class="tb-hl-function">useSelf</span>()&nbsp;<span class="tb-hl-comment">// 获取当前组件实例</span></div><div class="tb-code-line"><br></div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-builtin">console</span>.<span class="tb-hl-function">log</span>(self.slots)</div><div class="tb-code-line">&nbsp;&nbsp;}</div><div class="tb-code-line">})</div></div><span class="tb-pre-lang">TypeScript</span></div></pre>
<p>我们可以根据需要调用 slots 的 insert()、delete() 等方法，对插槽进行增加或修改。更多方法请参考 API 下 slots 相关文档。&nbsp;</p>
<h2>组件选项</h2>
<p>在前面的文档中，我们已经创建了各种常见形态的组件，<span style="background-color:rgb(255, 255, 255);color:rgb(73, 80, 96)">你当然可以</span>可以根据自己的需要，创建更多的组件。但要更清晰的了解 Textbus 的组件，我们还需要详细了解创建组件时的配置项。</p><pre lang="Tsx" theme="starry" line-number class="tb-pre"><div class="tb-pre-content"><div style="width:2.5em" class="tb-code-line-number-bg"></div><div class="tb-code-content"><div class="tb-code-line"><span class="tb-hl-comment">/**</span></div><div class="tb-code-line"><span class="tb-hl-comment">&nbsp;* Textbus 扩展组件接口</span></div><div class="tb-code-line"><span class="tb-hl-comment">&nbsp;*/</span></div><div class="tb-code-line"><span class="tb-hl-keyword">export</span>&nbsp;<span class="tb-hl-keyword">interface</span>&nbsp;<span class="tb-hl-class-name">ComponentOptions</span>&lt;<span class="tb-hl-class-name">State</span>,<span class="tb-hl-class-name">&nbsp;SlotState</span>,<span class="tb-hl-class-name">&nbsp;Extends</span>&gt; {</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-comment">/** 组件名 */</span></div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;name:&nbsp;<span class="tb-hl-builtin">string</span>;</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-comment">/** 组件类型 */</span></div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;type: ContentType;</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-comment">/** 组件是否可拆分 */</span></div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;separable?:&nbsp;<span class="tb-hl-builtin">boolean</span>;</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-comment">/** 输入语法糖支持 */</span></div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;zenCoding?: ZenCodingGrammarInterceptor&lt;ComponentInitData&lt;State, SlotState&gt;&gt; | ZenCodingGrammarInterceptor&lt;ComponentInitData&lt;State, SlotState&gt;&gt;[];</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-comment">/**</span></div><div class="tb-code-line"><span class="tb-hl-comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* 组件初始数据校验</span></div><div class="tb-code-line"><span class="tb-hl-comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* @param context</span></div><div class="tb-code-line"><span class="tb-hl-comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* @param initData</span></div><div class="tb-code-line"><span class="tb-hl-comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</span></div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;validate?(context: Textbus, initData?: ComponentInitData&lt;State, SlotState&gt;): ComponentInitData&lt;State, SlotState&gt;;</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-comment">/**</span></div><div class="tb-code-line"><span class="tb-hl-comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* 组件初始化实现</span></div><div class="tb-code-line"><span class="tb-hl-comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</span></div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;setup?(): Extends;</div><div class="tb-code-line">}</div></div><span class="tb-pre-lang">Tsx</span></div></pre>
<h3 style="background-color:rgb(255, 255, 255)"><span style="color:rgb(73, 80, 96)">组件名字 name</span></h3>
<p style="background-color:rgb(255, 255, 255)"><span style="color:rgb(73, 80, 96)">一个字符串，组件的名字，在一个 Textbus 实例中，它<strong>必须是唯一</strong>的。Textbus 在查找和储存历史记录时，都会用到它。</span></p>
<h3>组件类型 type</h3>
<p>组件类型。在 Textbus 的数据定义中，共有三种数据类型，它们分别是：</p>
<ul>
  <li class="tb-list-item"><strong>块组件</strong>：ContentType.BlockComponent</li>
  <li class="tb-list-item"><strong>行内组件</strong>：Component.InlineComponent</li>
  <li class="tb-list-item"><strong>文本</strong>：ContentType.Text</li>
</ul>
<p>需要注意的是，这里定义的块组件和行内组件，在展示上并不总是和 HTML 是一样的，它只是 Textbus 用于计算格式变换和结构变换的依据。事实上，你完全可以定义一个块组件，但让它显示效果像一个行内组件，亦或是相反。不过，我们还是建议你在定义组件类型的时候，尽量和展示效果保持一致。</p>
<h3>是否可拆分 separable</h3>
<p>布尔值，默认为 false，表示一个组件是否可以拆分。Textbus 在做格式变换时，会根据些项配置决定是否拆分当前组件。</p>
<p>如列表组件（ul，ol），可把某一个子插槽变更为段落，也可拆分为两个列表组件。如果是这类型的组件，我们应该配置为 true。</p>
<p>如表格组件，我们不可以把表格的某一个单元格插槽单独拿出来，则我们应该配置为 false</p>
<h3>输入语法糖 zenCoding</h3>
<p>通过配置一个或一组的语法规则，可以实现输入实时转换，如 Markdown 语法的支持。当你，你也可以完全自定义自己的语法规则。</p>
<p>其中：</p>
<ul>
  <li class="tb-list-item"><strong>match</strong>&nbsp;为一个正则表达式或是一个函数，用于匹配当前输入项是否满足语法条件</li>
  <li class="tb-list-item"><strong>key</strong>&nbsp;为触发 Textbus 转换的输入键值，如 Todolist 这里，我们以用户输入空格作为触为条件</li>
  <li class="tb-list-item"><strong>generateInitData</strong>&nbsp;为一个函数，会把当前匹配到的文本内容传入。你可以根据传入的字符生成当前组件实例化时所需要的参数并返回</li>
</ul>
<tb-alert data-type="default" class="tb-alert tb-alert-default">
  <div><strong style="color:rgb(58, 170, 250)">提示</strong>：zenCoding 语法规则不仅限于 markdown。实际上，你可以定义任何你想要的语法，如：#table:row=3,col=4 转换为一个 3 行 4 列的表格。</div>
</tb-alert>
<h3>数据验证 validate()</h3>
<p>组件数据校验方法，我们可以对外部输入的数据做校验，也可以提供默认数据给新创建的组件。</p>
<h3>组件设置 setup()</h3>
<p>组件的核心方法。你可以在该方法内定义组件的行为、数据，也可以对外暴露数据和方法。</p>