import bg from '../assets/tbus-bg.jpg'
import qqGroup from '../assets/qq-group.png'

export const html = `<tb-jumbotron style="background-image:url(&quot;${bg}&quot;);background-size:cover;background-position:center center;min-height:220px"><div><h1 style="color:rgb(255, 255, 255)">Hello, world!</h1><p><span style="color:rgb(255, 255, 255)">你好，我是 Textbus，一个给你带来全新体验的富文本开发框架。</span><br><span style="color:rgb(255, 255, 255)">现在我们开始吧！</span></p></div></tb-jumbotron><p style="background-color:rgb(255, 255, 255);color:rgb(85, 85, 85);font-size:16px;font-family:Lato, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif">Textbus 是一个以组件为中心，数据驱动的富文本编辑器开发框架！为了解决传统富文本开发中遇到的各种问题，我们完全自主设计了富文本的组件系统和格式系统，旨在降低富文本的开发成本，帮助你更轻松的扩展出丰富的富文本功能。不管你是富文本开发的老鸟，亦或是前端的新手，你都将会在 Textbus 中感受到非凡的开发体验和扩展能力。</p><p style="background-color:rgb(255, 255, 255)">赶快运行起来，看一看效果：<br></p><pre lang="TypeScript" theme="light" class="tb-pre"><div style="width:2.5em" class="tb-code-line-number-bg"></div><div class="tb-code-content"><div class="tb-code-line"><span class="tb-hl-keyword">import</span>&nbsp;{ createEditor }&nbsp;<span class="tb-hl-keyword">from</span>&nbsp;<span class="tb-hl-string">'@textbus/editor'</span>;</div><div class="tb-code-line"><br></div><div class="tb-code-line"><span class="tb-hl-keyword">const</span>&nbsp;editor =&nbsp;<span class="tb-hl-function">createEditor</span>();</div><div class="tb-code-line">editor.<span class="tb-hl-function">mount</span>(document.<span class="tb-hl-function">getElementById</span>(<span class="tb-hl-string">'editor'</span>))</div><div class="tb-code-line">editor.onChange.<span class="tb-hl-function">subscribe</span>(() =&gt; {</div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-keyword">const</span>&nbsp;{content, styleSheets} = editor.<span class="tb-hl-function">getContents</span>();</div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-builtin">console</span>.<span class="tb-hl-function">log</span>(content, styleSheets);</div><div class="tb-code-line">})</div></div><span class="tb-pre-lang">TypeScript</span></pre><p>为什么选择 Textbus，相较于传统的富文本编辑器，Textbus 都有什么优点呢？我们做一个简单的梳理：</p><ul><li class="tb-list-item"><strong>组件化</strong>：在富文本中做交互在传统富文本中是很难的，而 Textbus 通过组件可以方便的实现在文档编辑中复杂的交互效果；</li><li class="tb-list-item"><strong>数据驱动</strong>：不需要手动操作 DOM 去完成文档内容的编辑，完全的数据驱动，使文档总是能得到预期的结果；</li><li class="tb-list-item"><strong>轻量化内核</strong>：Textbus 内核中只抽象了富文本的选区、格式转换和数据模型。没有内置任何其它的功能，你可以按你的想法完全定制；</li><li class="tb-list-item"><strong>高扩展能力</strong>：你不但可以添加任意样式，还可以通过组件扩展任意的功能，完成诸如钉钉文档、飞书文档、石墨文档等功能；</li><li class="tb-list-item"><strong>语法糖</strong>：你可以根据自己的需要扩展不限于 Markdown 之类的语法糖，让用户可以更便捷的完成格式化；</li><li class="tb-list-item"><strong>协作支持</strong>：通过对接 Textbus 内核，可以实现 OT 或 CRDT 多人在线协作能力；</li><li class="tb-list-item"><strong>高性能</strong>：由 Textbus 根据富文本场景定制的渲染器，大多数情况下，可以在 1ms 之内完成视图的渲染；</li><li class="tb-list-item"><strong>jsx/tsx 支持</strong>：可以通过 jsx 或 tsx 编写组件，灵活性更强，而不用学习其它的方言。</li></ul><p>来回顾一下 Textbus 的发展历史吧：</p><tb-timeline><div class="tb-timeline-item tb-timeline-item-primary"><div class="tb-timeline-line"></div><div title="null" class="tb-timeline-icon"></div><div class="tb-timeline-content"><div><span style="font-size:18px"><strong>立项&nbsp;</strong></span><span style="color:rgb(119, 119, 119);font-size:15px">需求的起始</span></div><p>因当时工作需要，要 copy 一些表格或 word 文档到富文本编辑器内，同时，也希望能在富文本内做一些简单的编辑。经过一番调研，市面上的富文本要么把样式丢了，要么表格编辑功能不够，要么产出的样式很脏，会遗留很多从 word 或 excel 拷贝过来的脏数据。</p><p>为了先满足暂时的业务的需求，我先使用了某编辑器，同时用所有的业余时间着手展开富文本编辑器的研发工作。<br></p></div></div><div class="tb-timeline-item tb-timeline-item-primary"><div class="tb-timeline-line"></div><div title="null" class="tb-timeline-icon"></div><div class="tb-timeline-content"><div><span style="font-size:18px"><strong>contenteditable 的实践&nbsp;</strong></span><span style="color:rgb(119, 119, 119);font-size:15px">第一个版本</span></div><p>和其它富文本编辑器一样，一开始也是基于 DOM 的 contenteditable 属性。经过3个月的开发，初具雏形，但发现了一个很大的问题。</p><ol><li class="tb-list-item">浏览器的行为不可控，不同的浏览器对同样的操作产出的结果不一样；</li><li class="tb-list-item">编辑的数据不可控。我完全不知道一个加粗操作会产生什么样的 DOM 结构；</li><li class="tb-list-item">产出的数据很脏，比如加粗一段文字，在经过几次操作之后，可能会同时出现多个 strong 标签并列的情况；</li><li class="tb-list-item">因为内容不可控，所以也并没有很好的解决从 word 或 excel 拷贝数据太脏的问题。<br></li></ol><p>其实问题远不止以上 4 点，但这对于我来说，是完全不能接受的。<br></p></div></div><div class="tb-timeline-item tb-timeline-item-primary"><div class="tb-timeline-line"></div><div title="null" class="tb-timeline-icon"></div><div class="tb-timeline-content"><div><span style="font-size:18px"><strong>数据驱动视图的探索&nbsp;</strong></span><span style="color:rgb(119, 119, 119);font-size:15px">第二个版本</span></div><p>这个版本完全抛弃了 contenteditable 的方案，采用自定义输入功能，重新设计了架构。采用可编辑片段（Fragment）+ 格式化信息（Formatter）的组合方式，和现在大家见到的如 Draft.js、Slate.js 类似。这种方案有一个很大的优点，生成的结果不脏了，从 word、excel 或网页拷贝过来的数据不但能保留必要的样式，冗余的数据也自动清理掉了。同时也可以很方便的实现一些特定功能，如实时代码高亮等。</p><p>虽然经过以上设计，解决了第一个版本的问题，但又引出的新问题，如：如何保证一个固定的结构不可编辑，同时指定某些内容是可编辑的？这是一个很常见的需求，如卡片，上面一张图片，下面一小段描述性文字。传统的编辑器是把外层设置为 contenteditable = false，内层再重置 contenteditable = true，但 Textbus 已抛弃了这种方案，不能重回老路。<br></p></div></div><div class="tb-timeline-item tb-timeline-item-primary"><div class="tb-timeline-line"></div><div title="null" class="tb-timeline-icon"></div><div class="tb-timeline-content"><div><span style="font-size:18px"><strong>黎明前的黑暗&nbsp;</strong></span><span style="color:rgb(119, 119, 119);font-size:15px">再一次自我否定</span></div><p>经过前面两次版本的经验，首先验证了两件事：</p><ol><li class="tb-list-item">基于 contenteditable 的路是行不通的；</li><li class="tb-list-item">数据驱动是解决问题的根本之道。<br></li></ol><p>如果说写代码有什么事是令人痛苦的，那么我觉得就是把自己几个月辛苦的成果完全抛弃。如果说有什么是比这个是更痛苦的，那就是抛弃两次！到这个时候，我已经在富文本的研究上花了一年的时间了，最终的结果却不尽人意。如果没有从根本上解决富文本的抽象，那么我所做的一切不过是重复造轮子，最大的作用就是给自己涨一点经验。</p></div></div><div class="tb-timeline-item tb-timeline-item-primary"><div class="tb-timeline-line"></div><div title="null" class="tb-timeline-icon"></div><div class="tb-timeline-content"><div><span style="font-size:18px"><strong>组件化设计&nbsp;</strong></span><span style="color:rgb(119, 119, 119);font-size:15px">打开新世界的大门</span></div><p>我不是一个喜欢轻言放弃的人，尤其是对自己有兴趣的事情上！</p><p>结合我自己的经验和现代前端框架的设计，组件化是一条可行之路。但富文本因有其特殊性，肯定不能照搬前端框架的设计思路。这时，如何在富文本里做组件化，就成了决定 Textbus 成败的关键。</p><div>经过短时间的休整，我重新开始了富文本的探索之路。</div><p>我分析了现代前端框架组件的特点，都是由一段固定的 html 模板，一部分数据，再加上插槽基本就组成了一个组件的形态。而如果要在富文本里做组件，就不仅要具备以上要素，还需要提供动态编辑的能力。</p><p>在典型的前端应用场景里，组件树的形态和分支是可预测的，无非就是根据一些数据，填充占位符，再根据一些条件，判断展示哪一个预设的组件或 DOM 节点。富文本不是这样的。富文本所有数据的组装是不可预测的，会随着用户的添加、删除或编辑操作的变化而产生变化。</p><p>基于富文本的特殊需求，我重新设计组件系统。该组件系统抽象了富文本编辑操作特点，提供了统一的封装，只要继承自现有组件系统的的抽象类，就可以自动获得在 Textbus 里和其它组件的组合编辑能力。至此，Textbus 终于找到了一条正确的设计思路！</p></div></div><div class="tb-timeline-item tb-timeline-item-primary"><div class="tb-timeline-line"></div><div title="null" class="tb-timeline-icon"></div><div class="tb-timeline-content"><div><span style="font-size:18px"><strong>性能瓶颈的第一次考验&nbsp;</strong></span><span style="color:rgb(119, 119, 119);font-size:15px">渲染器短板</span></div><p>在组件化设计告一段落之后，我信心十足，以为 Textbus 迎来了春天，但打脸接踵而至。我发现 Textbus 很容易就遇到性能问题，由于 Textbus 的视图是由数据驱动的，随着编辑内容的增长，更新所需的 diff 时间就会越长，我习惯性的在每一个函数的开始调用和结束调用的地方加上时间戳，发现每一个函数所花费的时间并不长。我又仔细梳理了视图更新的流程，在当前的架构下，也没有哪一步计算是多余的。一时间，我陷入了沉默，因为直觉告诉我，Textbus 又要大改了。</p><p>然而，性能优化谈何容易，近两个月的时间，我都没有思考出一个较好的方案。<br></p></div></div><div class="tb-timeline-item tb-timeline-item-primary"><div class="tb-timeline-line"></div><div title="null" class="tb-timeline-icon"></div><div class="tb-timeline-content"><div><span style="font-size:18px"><strong>可维护性的升级&nbsp;</strong></span><span style="color:rgb(119, 119, 119);font-size:15px">剪不断，理还乱</span></div><p>又过了一段时间，当我把渲染性能问题解决了之后，这时，Textbus 官方群里的小伙伴也越来越多了，由于当时并没有很好的文档，很多小伙伴会提出一些问题。有时，我可能回答得不及时，有的小伙伴都自己去看源代码去了。</p><p>反馈接着就来了，一部分群友表示，源代码太复杂，看不懂！</p><p>这不得不说，因为 Textbus 一直处于探索之中，想用最短的时间验证设计思路和可行性，所以源代码的组织架构上，还存在不少短板。又因为富文本编辑器本身的复杂度较高，导致各个类之间存在的复杂的引用关系。要解决这个问题，还需要从设计上入手，为此，专门写了一套依赖注入的库，即&nbsp;<a target="_blank" href="https://github.com/tbhuabi/di">@tanbo/di</a>&nbsp;，通过依赖注入的方式，实现了各个类之间的解耦。</p><p>至此，Textbus 发布 1.0.0 的 alpha 版本。<br></p></div></div><div class="tb-timeline-item tb-timeline-item-primary"><div class="tb-timeline-line"></div><div title="null" class="tb-timeline-icon"></div><div class="tb-timeline-content"><div><span style="font-size:18px"><strong>2.0 的诞生</strong></span><span style="font-size:15px;color:#777">&nbsp;再一次降低复杂度</span></div><p>随着后续 1.0 版本的正式发布，我同样把装饰器带到了组件，虽然代码看上去更整洁了，但对大多数小伙伴来说，编写 Textbus 的扩展也需要学习装饰器和 TypeScript。这对于上手成本还是过高，另外，原来一直和大家承诺的在线协作能力也一直没有实现。</p><p>痛定思痛，我决定在 1.0 的经验之上，更进一步。</p><p>新版本并没有完全按照 1.0 的设计，而是把协作作为基础设计目标，同时，结合现代前端框架 hooks 的特点，重新设计。要求，新的版本不但能降低扩展难度，同时，也不绑定装饰器和 TypeScript。在经过一年时间的开发、测试终于发布的 2.0 正式版。</p></div></div><div class="tb-timeline-item tb-timeline-item-primary"><div class="tb-timeline-line"></div><div title="null" class="tb-timeline-icon"></div><div class="tb-timeline-content"><div><span style="font-size:18px"><strong>未来展望</strong></span><span style="font-size:15px;color:#777">&nbsp;3.0</span></div><p>随着 2.0 版本的稳定，Textbus 基本达到的预设的目标，并且完成得很好，我们将再接再厉，持续优化，并积极吸取广大用户的意见和建议，为大家提供更好用的富文本基础设施。</p><p>目前 3.0 的一些改动已在内部开发当中，预计这一个版本不会有太大改变，主要还是在 2.0 的基础上进一步优化，让我们一起期待！</p></div></div></tb-timeline><p>这就是 Textbus 的诞生之路，事情往往不会一帆风顺，作为作者，我能做的也只有一直坚持不懈。Textbus 并不完美，还继续探索下去，这里也感谢 Textbus 的使用者对 Textbus 的支持与包容！</p><p>我们再来看看 Textbus 中一些核心的概念吧：<br></p><tb-word-explain><div class="tb-word-explain-title-group"><div style="text-align:right" class="tb-word-explain-title"><code>Component</code><br></div><div style="text-align:right" class="tb-word-explain-subtitle">组件<br></div></div><div class="tb-word-explain-detail">Textbus 的组件和传统 web 开发中的组件其实是差不多的，由一部分相对固定的模板和动态的插槽组成。<br></div></tb-word-explain><tb-word-explain><div class="tb-word-explain-title-group"><div style="text-align:right" class="tb-word-explain-title"><code>ComponentLoadder</code><br></div><div style="text-align:right" class="tb-word-explain-subtitle">组件加载器<br></div></div><div class="tb-word-explain-detail">用于把 DOM 树转换为 Textbus 组件类的转换器。<br></div></tb-word-explain><tb-word-explain><div class="tb-word-explain-title-group"><div style="text-align:right" class="tb-word-explain-title"><code>Slot</code></div><div style="text-align:right" class="tb-word-explain-subtitle">可编辑片段</div></div><div class="tb-word-explain-detail">一段可编辑的内容，可以是字符串或组件。同时，Slot 还保存对应内容的样式。<br></div></tb-word-explain><tb-word-explain><div class="tb-word-explain-title-group"><div style="text-align:right" class="tb-word-explain-title"><code>Formatter</code><br></div><div style="text-align:right" class="tb-word-explain-subtitle">格式化类</div></div><div class="tb-word-explain-detail">在输入时，用于读取 HTML 的样式。在输出时，用于渲染 Slot 的样式并生成虚拟 DOM。<br></div></tb-word-explain><p>更多的内容请查看文档，如果你的疑问，你还可以加入我们的官方 QQ 群，和核心开发人员直接提出需求，我们会尽最大努力满足：</p><p style="text-align:center"><img src="${qqGroup}" style="width:252px;height:auto" class="tb-img"></p><p>好了，简单的介绍就到这里为止吧，希望你使用愉快！</p><p style="text-align:right">——Textbus 开发团队</p><p style="text-align:right">2022 年 9 月 24 日<br></p>`
